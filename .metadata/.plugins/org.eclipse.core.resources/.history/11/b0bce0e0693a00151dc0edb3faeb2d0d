/*
 * GeneralBinaryTree.cpp
 *
 *  Created on: Aug 3, 2015
 *      Author: user
 */
#include "GeneralBinaryTree.h"

GeneralBinaryTree::GeneralBinaryTree(){
	root=NULL;
}

BinaryTreeNode * GeneralBinaryTree::insert(int newdata){
BinaryTreeNode *newnode = new BinaryTreeNode();
newnode->left = NULL;
newnode->right = NULL;
newnode->data = newdata;
cout<<"inserted data "<<newdata<<"successfully"<<endl;
return newnode;
}

void GeneralBinaryTree::insertRandom(){
/*
	root=insert(1);
	root->left=insert(2);
	root->right=insert(3);
	root->left->left=insert(4);
	root->left->right=insert(5);
	root->right->right=insert(6);
	root->right->left=insert(7);

//Foldable Binary tree data
	root=insert(10);
	root->left=insert(7);
	root->right=insert(15);

	root->left->right=insert(6);
	root->right->right=insert(6);
	root->right->left=insert(7);
	*/
	root=insert(1);
		root->left=insert(2);
}
void GeneralBinaryTree::inorderHelper(BinaryTreeNode *node){
	    if(node){
		inorderHelper(node->left);
		cout<<node->data<<"->";
		inorderHelper(node->right);
	}
}
/*********************************************************************
 * Start Double binary tree
 ********************************************************************/
void GeneralBinaryTree::doubleTreeHelper(BinaryTreeNode* root){
	if(root==NULL){
			return;
		}
	doubleTreeHelper(root->left);
	doubleTreeHelper(root->right);
	if(root->left){
				BinaryTreeNode* newnode=insert(root->data);
				BinaryTreeNode* currleft=root->left;
				root->left=newnode;
				newnode->left=currleft;
			}
			else{
				BinaryTreeNode* newnode=insert(root->data);
				root->left=newnode;
			}
}
void GeneralBinaryTree::doubleTree(){
	if(root){
		doubleTreeHelper(root);
		cout<<"Inorder.."<<endl;
		inorderHelper(root);
	}

}
/*********************************************************************
 * End Double binary tree
 ********************************************************************/
int GeneralBinaryTree::heightBinaryTreeHelper(BinaryTreeNode *root){
	if(root == NULL){
		return 0;
	}
	int lheight=heightBinaryTreeHelper(root->left);
	int rheight=heightBinaryTreeHelper(root->right);
	if(lheight>rheight){
		return lheight+1;
	}
	else return rheight+1;
}
int GeneralBinaryTree::maxWidth(){
	int height=heightBinaryTreeHelper(root);
	int maxwidth=0;
	for(int i=1;i<=height;i++){
		int width=maxWidthHelper(root,i);
		cout<<endl<<"Width of level "<<i<<"is "<<width<<endl;
		if(width>maxwidth){
			maxwidth=width;
		}
	}
	return maxwidth;
}

int GeneralBinaryTree::maxWidthHelper(BinaryTreeNode *root,int level){
	if(root==NULL){
		return 0;
	}
	if(level==1){
		return 1;
	}

	return maxWidthHelper(root->left,level-1)+
			maxWidthHelper(root->right,level-1);

}

/********************************************************************************
 * Start Maximum width of binary tree O(n)
 ********************************************************************************/
int GeneralBinaryTree::maxWidthPreorder(){
	int height=heightBinaryTreeHelper(root);
	int a[height],maxwidth=INT_MIN;
	for(int i=1;i<=height;i++){
		a[i]=0;
	}
	if(root){
		maxWidthHelperPreorder(root,1,a);
	}
	for(int i=1;i<=height;i++){
		if(a[i]>maxwidth){
			maxwidth=a[i];
		}
	}
	return maxwidth;
}
void GeneralBinaryTree::maxWidthHelperPreorder(BinaryTreeNode *root,int level,int a[])
{
	if(root){
		a[level]++;
		maxWidthHelperPreorder(root->left,level+1,a);
		maxWidthHelperPreorder(root->right,level+1,a);
	}
}

/********************************************************************************
 * End Maximum width of binary tree O(n)
 ********************************************************************************/

/********************************************************************************
 * Start Get level of a node in binary tree O(n)
 ********************************************************************************/
int GeneralBinaryTree::getLevelOfNode(int data){
	if(root){
		return getLevelOfNodeHelper(root,data,1);
	}
	return -1;
}

int GeneralBinaryTree::getLevelOfNodeHelper(BinaryTreeNode* root,int data,int level){
if(root==NULL){
	return -1;
}
if(data==root->data){
	return level;
}
int downlevel= getLevelOfNodeHelper(root->left,data,level+1);
if(downlevel!=-1){
	return downlevel;
}
else return getLevelOfNodeHelper(root->right,data,level+1);
}

/********************************************************************************
 * End Get level of a node in binary tree O(n)
 ********************************************************************************/

/********************************************************************************
 * Start Determine if binary tree is foldable O(n)
 ********************************************************************************/
bool GeneralBinaryTree::isFoldable(){
if(root){
	return isFoldableHelper(root->left,root->right);
}
return true;
}

bool GeneralBinaryTree::isFoldableHelper(BinaryTreeNode* node1,BinaryTreeNode* node2){
if(node1==NULL && node2==NULL){
	return true;
}
if(node1==NULL||node2==NULL){
	return false;
}
return isFoldableHelper(node1->left,node2->right)&&
		isFoldableHelper(node1->right,node2->left);
}
/********************************************************************************
 * End Determine if binary tree is foldable O(n)
 ********************************************************************************/
/********************************************************************************
 * Start Print nodes at distance k from root O(n)
 ********************************************************************************/
void GeneralBinaryTree::printNodesAtDistanceKFromRoot(int k){
	if(root){
		printNodesAtDistanceKFromRootHelper(root,k);
	}
}

void GeneralBinaryTree::printNodesAtDistanceKFromRootHelper(BinaryTreeNode* root,int k){
	if(root==NULL){
		return;
	}
	if(k==0){
		cout<<root->data<<"->";
		return;
	}
	else if(k>0){
		printNodesAtDistanceKFromRootHelper(root->left,k-1);
		printNodesAtDistanceKFromRootHelper(root->right,k-1);
	}
}
/********************************************************************************
 * End Print nodes at distance k from root O(n)
 ********************************************************************************/
void printAncestorsOfNode(int data){
	if(root){
		int a[150];
		printAncestorsOfNode(root,data,int a[],int index);
	}
}
